#ifndef ARRAY_H
#define ARRAY_H

#include <stddef.h>

/* Типоуниверсальный динамический массив с вместимостью */
struct array;
typedef struct array array;

/* Обеспечение работы типоуниверсального динамического массива с вместимостью */

/* Минимальная вместимость массива по умолчанию
 */
#define ARRAY_MIN_CAPACITY 10

/* Тип функции для вычисления вместимости по размеру
 */
typedef size_t (*array_capacity_f) (size_t);

/* Создание элемента массива e
 * (должна вернуть 0 в случае успеха, не 0 в случае ошибки)
 */
typedef int (*array_alloc_f) (void *e, void *data);

/* Высвобождение элемента массива e
 */
typedef void (*array_free_f) (void *e, void *data);

/* Клонирование элемента массива src в элемент dst размера size
 * (должна вернуть 0 в случае успеха, не 0 в случае ошибки)
 */
typedef int (*array_clone_f) (void *dst, const void *src, void *data);

/* Параметры для инициализации и функции работы с элементами массива */
typedef struct array_pars
{
    size_t           min; /* минимальная вместимость (не менее 1)                                */
                          /* если 0, используется ARRAY_MIN_CAPACITY                             */
    array_capacity_f fr;  /* требуемая вместимость массива по размеру                            */
                          /* если NULL, используется fr(count) = 2*count                         */
    array_capacity_f fs;  /* порог вместимости, в случае превышения котого                       */
                          /* вместимость следует уменьшить до требуемой                          */
                          /* если NULL, используется fr(count) = 4*count                         */
    array_alloc_f    fa;  /* функция создания элемента массива                                   */
                          /* если NULL, не используется                                          */
    void            *da;  /* данные, используемые для создания элемента массива                  */
                          /* передаются в fa,                                                    */
                          /* должны быть доступны в памяти все время жизни массива               */
                          /* изменение в памяти отразится на последующих созданиях элементов     */
    array_free_f     ff;  /* функция удаления элемента массива                                   */
                          /* если NULL, не используется                                          */
    void            *df;  /* данные, используемые для удаления элемента массива                  */
                          /* передаются в ff,                                                    */
                          /* должны быть доступны в памяти все время жизни массива               */
                          /* изменение в памяти отразится на последующих удалениях элементов     */
    array_clone_f    fc;  /* функция клонирования элемента массива                               */
                          /* если NULL, используется memcpy и &size в качестве dc                */
    void            *dc;  /* данные, используемые для копирования элемента массива               */
                          /* передаются в fс,                                                    */
                          /* должны быть доступны в памяти все время жизни массива               */
                          /* изменение в памяти отразится на последующих клонированиях элементов */

} array_pars;

/* Инициализация массива нулевой длины.
 * size - размер элемента массива
 * pars - параметры инициализации массива
 *        используются параметры по умолчанию если pars = NULL или значения 0 или NULL
 * В случае успеха возвращает массив, в случае ошибки - NULL
 */
array  *array_alloc (size_t size, const array_pars *pars);

/* Создание копии массива a (элементы копируются в памяти)
 * В случае ошибки возвращает NULL
 */
array  *array_clone (const array *a);

/* Освобождение ранее инициализированного массива.
 */
void   array_free (array *a);

/* Возвращает размер переменной array
 * (sizeof не работает для неполного типа)
 */
size_t array_sizeof();

/* Изменение элемента массива a с индексом i на e
 * Безопасно, с проверкой границ массива
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое.
 */
int array_set (array *a, size_t i, const void *e);
/* Получение элемента массива a по индексу i
 * Безопасно, с проверкой границ массива
 * Возвращает 0 в случае успеха, значение записывается в *e .
 * Возвращает 1 в случае неудачи, *e сохраняет значение.
 */
int array_get (const array *a, size_t i, void *e);

/* Получение указателя на элемент массива a по индексу i
 * небезопасно, без проверки границ массива
 */
void * array_element (array *a, size_t i);
const void * array_element_const (const array *a, size_t i);

/* Установка вместимости массива в capacity элементов.
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и вместимость.
 */
int    array_set_capacity (array *a, size_t capacity);

/* Возвращает вместимость массива.
 */
size_t array_capacity (const array *a);

/* Установка вместимости массива в соответствие с размером.
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и вместимость.
 */
int    array_adjust_capacity (array *a);

/* Задает минимальную вместимости массива и устанавливает вместимость
 * Если min == 0, min = ARRAY_MIN_CAPACITY
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и вместимость.
 */
int    array_set_min_capacity (array *a, size_t min);
/* Задает функцию определения требуемой вместимости массива
 * и устанавливает вместимость
 * Если fr = NULL, fr(count) = 2*count
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и вместимость.
 */
int    array_set_capacity_fr (array *a, array_capacity_f fr);
/* Установка функции определения вместимость, в случае превышения которой
 * при уменьшения размера массива ее следует уменьшить до требуемой
 * и устанавливает вместимость
 * Если fs = NULL, fs(count) = 4*count
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и вместимость.
 */
int    array_set_capacity_fs (array *a, array_capacity_f fs);

/* Установка размера массива с изменением вместимости по необходимости.
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое и размер.
 */
int    array_resize (array *a, size_t count);
/* Получение числа элементов массива.
 */
size_t array_size (const array *a);

/* Вставка элемента e в конец массива a.
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое.
 */
int    array_insert (array *a, const void *e);
/* Удаление элемента с номером i из массива a.
 * Перемещает элемент на место удаляемого.
 * Возвращает 0 в случае успеха, изменяет a.
 * Возвращает 1 в случае неудачи, массив сохраняет содержимое.
 */
int    array_delete (array *a, size_t i);

/* Функция обработки элемента массива
 * e - элемент массива
 * data - параметры функции
 */
typedef void (*array_callback_f) (void *e, void *data);
typedef void (*array_callback_f_const) (const void *e, void *data);
/* Функции поэлементной обработки массива
 * Проход производится в порядке возрастания индексов элементов путем применения функции f к каждому элементу
 * data передается в каждую функцию f сохраненим значения
 */
void array_foreach (array *a, array_callback_f f, void *data);
void array_foreach_const (const array *a, array_callback_f_const, void *data);

/* Функция обработки элемента массива с учетом индекса
 * e - элемент массива
 * i - индекс элемента
 * n - размер (количество элементов) массива
 * data - параметры функции
 */
typedef void (*array_icallback_f) (void *e, size_t i, size_t n, void *data);
typedef void (*array_icallback_f_const) (const void *e, size_t i, size_t n, void *data);
/* Функции поэлементной обработки массива с учетом индекса
 * Проход производится в порядке возрастания индексов элементов путем применения функции f к каждому элементу
 * data передается в каждую функцию f сохраненим значения
 */
void array_iforeach (array *a, array_icallback_f f, void *data);
void array_iforeach_const (const array *a, array_icallback_f_const, void *data);

#endif
